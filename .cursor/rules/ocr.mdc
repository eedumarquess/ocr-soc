---
alwaysApply: true
---

ğŸ§  PaddleOCR Medical Reports â€” Cursor Rules
Core Philosophy
Expert system for medical text extraction from scanned reports. Prioritize accuracy, determinism, and confidentiality.

ğŸ¯ Principles

Functional-first: Pure functions, avoid classes
RORO pattern: Receive Object, Return Object
Deterministic: Same input â†’ same output
Modular: preprocess â†’ extract â†’ postprocess â†’ validate
Type-safe: Strict typing + Pydantic v2
Guard clauses: Validate early, fail fast

ğŸ“¦ Structure
ocr/
â”œâ”€â”€ pipelines/
â”‚   â”œâ”€â”€ preprocess_image.py
â”‚   â”œâ”€â”€ extract_text.py
â”‚   â”œâ”€â”€ postprocess_text.py
â”‚   â””â”€â”€ validate_output.py
â”œâ”€â”€ models/ocr_result.py
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ image_io.py
â”‚   â””â”€â”€ medical_rules.py
â””â”€â”€ tests/test_*.py

ğŸ”§ Implementation
PaddleOCR Setup
pythonfrom paddleocr import PaddleOCR

ocr = PaddleOCR(
    use_angle_cls=True,
    lang="por",
    det_db_unclip_ratio=1.6,
    use_gpu=True,
    show_log=False
)
Data Model
pythonfrom pydantic import BaseModel, Field

class OCRResult(BaseModel):
    text: str
    confidence: float | None = None
    bounding_boxes: list[tuple[int, int, int, int]] | None = None
    page_number: int = Field(default=1, ge=1)
    metadata: dict = Field(default_factory=dict)
Post-Processing
pythondef postprocess_text(result: OCRResult) -> OCRResult:
    if not result.text:
        return result
    
    text = result.text.strip()
    text = text.replace('|', '').replace('â€”', '-')
    text = ' '.join(text.split())
    text = normalize_medical_terms(text)
    
    return result.model_copy(update={'text': text})

ğŸ©º Medical Domain
Text Normalization

Strip artifacts: |, _, â€”
Normalize decimals: , â†’ .
Medical spelling corrections
Preserve original line order

Key-Value Extraction
pythonimport re

pattern = r"([\w\s]+):\s*([\d.,]+)\s*(g/dL|mg/dL|mmol/L)"
matches = re.findall(pattern, text)
Utilities
python# utils/medical_rules.py
MEDICAL_TERMS = {
    "hemoglohina": "hemoglobina",
    "glocose": "glicose",
    "creatnina": "creatinina",
}

def normalize_medical_terms(text: str) -> str:
    for wrong, correct in MEDICAL_TERMS.items():
        text = text.replace(wrong, correct)
    return text

âš¡ Performance

GPU: Enable for PaddleOCR
Caching: Use @lru_cache for normalizations
Batching: asyncio.gather() for multiple reports
Memory: Use BytesIO vs temp files
Vectorization: NumPy for image ops


ğŸ§ª Testing
pythonimport pytest
from unittest.mock import Mock

def test_postprocess_removes_artifacts():
    result = OCRResult(text="Test | text")
    processed = postprocess_text(result)
    assert '|' not in processed.text

ğŸ›¡ï¸ Error Handling
pythonclass InvalidImageError(Exception): pass
class OCRExtractionError(Exception): pass

def validate_image(img: np.ndarray) -> None:
    if img is None or img.size == 0:
        raise InvalidImageError("Empty image")

ğŸ“ Conventions
CategoryRuleStyleFunctional, typed, declarativeI/OPydantic models onlyErrorsGuard clauses, early returnsLogsStructured JSON, mask PIITestsPytest, mocked OCR outputs

âœ… Checklist

 All functions type-hinted
 Pydantic validation on I/O
 Medical terms normalized
 No PII in logs
 Tests with sample images
 GPU enabled if available
 Error handling on all image ops